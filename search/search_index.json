{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Course website","text":""},{"location":"#material","title":"Material","text":"<ul> <li>This website</li> <li>Google doc </li> </ul>"},{"location":"course_schedule/","title":"Course schedule","text":"<p>Note</p> <p>Apart from the starting time the time schedule is indicative. Because we can not plan a course by the minute, in practice the time points will deviate. </p>"},{"location":"course_schedule/#day-1","title":"Day 1","text":"block start end subject introduction 9:00 AM 9:15 AM [Introduction] block 1 9:15 AM 10:30 AM Reproducible research 10:30 AM 11:00 AM BREAK block 2 11:00 AM 12:30 PM Data structure 12:30 PM 1:30 PM BREAK block 3 1:30 PM 3:00 PM Exercices 3:00 PM 3:30 PM BREAK block 4 3:30 PM 5:15 PM S3 + S4 objects"},{"location":"course_schedule/#day-2","title":"Day 2","text":"block start end subject block 1 9:00 AM 10:00 AM Namespaces &amp; environment 10:00 AM 10:30 AM BREAK block 2 10:30 AM 11:00 PM Efficient programming block 3 10:30 AM 12:30 PM Exercices 12:30 PM 1:30 PM BREAK block 4 1:30 PM 3:00 PM Data manipulation 3:00 PM 3:30 PM BREAK block 4 3:30 PM 5:15 PM"},{"location":"course_schedule/#day-3","title":"Day 3","text":"block start end subject block 1 9:00 AM 10:30 PM R packaging 10:30 AM 11:00 AM BREAK block 2 11:00 AM 12:30 PM Advanced exercices 12:30 PM 1:30 PM BREAK block 3 1:30 PM 3:00 PM 3:00 PM 3:30 PM BREAK block 4 3:30 PM 5:15 PM"},{"location":"practicals_1/","title":"Practicals 1","text":"<p>Apart from the exercices suggested below, we suggest that you experiment with the topics we discussed this morning (especially those that you do not feel comfortable with): create and work with lists and factors, explore objects, etc.</p>"},{"location":"practicals_1/#exercice-0","title":"Exercice 0","text":"<p>If you are not comfortable yet with knitr and RMarkdown, try them. You can follow the exercises given at the end of the introductory slides. Do not hesitate to ask for help and material if required (we will not discuss knitr and Rmarkdown in more details during this course).</p>"},{"location":"practicals_1/#exercise-1","title":"Exercise 1","text":"<p>Suppose we have a list of amino acids, their masses and a protein sequence:</p> <pre><code>aminoacids &lt;- c(\"A\", \"R\", \"N\", \"D\", \"C\", \"E\", \"Q\", \"G\", \"H\", \"I\", \"L\", \"K\", \"M\", \"F\", \"P\", \"S\", \"T\", \"W\", \"Y\", \"V\" )\nmasses &lt;- c(71.0788, 156.1875, 114.1038, 115.0886, 103.1388, 129.1155, 128.1307, 57.0519, 137.1411, 113.1594, 113.1594, 128.1741, 131.1926, 147.1766, 97.1167, 87.0782, 101.1051, 186.2132, 163.1760, 99.1326)\nprotein &lt;- \"MEFARILOP\"\n</code></pre> <p>How can we use R to efficiently calculate the mass of the protein ?</p> <p>Hint: you can split the string using the <code>strsplit()</code> command in order to get individual letters, and then create some lookup table to find the masses and sum them.</p>"},{"location":"practicals_1/#exercice-2","title":"Exercice 2","text":"<p>Suppose that you are given information about the amount of fertilizer used on several parts of a field, in the form of a factor:</p> <pre><code>fert &lt;- factor( c(10, 20, 50, 30, 10, 20, 10, 45) )\n</code></pre> <p>Starting from the factor, how would you calculate the mean amount of fertilizer used ?</p>"},{"location":"practicals_1/#exercise-3","title":"Exercise 3","text":""},{"location":"practicals_1/#a","title":"A","text":"<p>The <code>table()</code> function allows you to count the number of occurrences of each value in a vector ; for example :</p> <pre><code>&gt; set.seed(5)\n&gt; data &lt;- sample(1:10, 10, replace=TRUE)\n\n&gt; table(data)\ndata\n2 3 5 6 7 9 \n1 2 1 1 2 3 \n</code></pre> <p>However, the table has \u2018gaps\u2019 in it. How could we obtain the same result, but including all numbers from 1 to 10, with a count of \u20180\u2019 when the value does not appear in the vector ?</p> <p>Side question: the tabulate() function solves part of our question here, but it is not entirely satisfactory. Why ?</p>"},{"location":"practicals_1/#b","title":"B","text":"<p>When plotting a boxplot, the order of the groups is generally alphabetical; for example, the boxplot created by the following commands has groups A, AB, B, BA, C.</p> <pre><code>a &lt;- runif(100)\ngroups &lt;- sample( c(\"A\", \"AB\", \"ABC\", \"B\", \"BC\", \"C\", \"CA\"), 100, replace=TRUE)\nboxplot(a ~ groups)\n</code></pre> <p>How you can easily force a different order  (e.g. A, B, C, AB, BC, CA, ABC) ?</p>"},{"location":"practicals_1/#c","title":"C","text":"<p>When conducting the linear regression described below, all groups are compared to the \u201cA\u201d group (as the intercept, chosen because it is the first group in alphabetical order). How can we force the <code>lm()</code> function to choose group \u201cref\u201d as the reference ?</p> <pre><code>set.seed(1)\ndata &lt;- runif(100)\ngroups &lt;- rep( c(\"ref\", \"a\", \"b\", \"c\"), each=25)\nsummary(lm(data~groups))\n</code></pre>"},{"location":"practicals_1/#exercise-4","title":"Exercise 4","text":""},{"location":"practicals_1/#a_1","title":"A","text":"<p>The following R code generates random data and fits a linear model:</p> <pre><code>set.seed(1)\nx &lt;- runif(10)\ny &lt;- 2*x + rnorm(10)\nmodel &lt;- lm(y~x)\nsummary(model)\n</code></pre> <p>How would you copy into a variable \u201cslope\u201d the slope of the regression line (the second regression coefficient) ? And how would you extract in a variable \u201cpvalue\u201d the p-value associated with it ?</p>"},{"location":"practicals_1/#b_1","title":"B","text":"<p>The following code fits an ANOVA model:</p> <pre><code>set.seed(1)\ngroups &lt;- rep(LETTERS[1:3], each=5 )\ndata &lt;- rnorm( length(groups) )\nmodel_anova &lt;- aov( data ~ groups )\nsummary(model_anova)\n</code></pre> <p>How would you extract the p-value provided by this model into a \u201cpvalue\u201d variable ?</p>"},{"location":"practicals_1/#exercise-5","title":"Exercise 5","text":"<p>Check how R implements \u201cfactors\u201d in principle. For example, where are the labels and the fact that the factor is ordered stored ? Where is the function that prints a factor, and the function that makes a summary out of the factor ?</p>"},{"location":"practicals_2/","title":"Exercice 1","text":"<p>Create an S3 class from scratch; imagine the name of the class, a function that creates it (and includes some data in it), and define at least a <code>print()</code>, a <code>summary()</code> and a <code>plot(</code>) methods for it.</p> <p>If you are looking for ideas, implement the following class:</p> <ul> <li>Class \u201cgeneexpr\u201d, which contains expression values for a set of     genes, in the form of a vector containing an arbitrary number of     gene expression values. Each expression value is accompanied by a     name for a gene (for example a gene symbol).</li> <li>\u201c<code>print</code>\u201d should print a nice summary of the dataset; in particular,     it should print the number of data points (and maybe the number of     unique gene names, in case the same gene/symbol appears several     times)</li> <li>\u201c<code>summary</code>\u201d should go a little bit further, and print the number of     genes plus a few information about the distribution (min, median,     max)</li> <li>\u201c<code>plot</code>\u201d should plot a histogram of the values.</li> </ul> <p>(for the next part, you may need to wait until we have progressed further in the course, talking about data manipulation). If you want to go further, you can implement a \u201cdiffexpr\u201d function, which will take 2 genexpr objects and calculate the differental expression (difference of expression) between the genes. It will have to take into account the fact that the two gene lists may not contain the same genes. In a second step, it should also be able to take into account duplicate gene measurements, in a way or another (average them ? take only the maximum ?).</p>"},{"location":"practicals_2/#exercice-2","title":"Exercice 2","text":"<p>The <code>summary()</code> function, when applied to numeric values, displays the \u201cfive-number summary\u201d of the values, as in the following example:</p> <pre><code>&gt; summary(runif(100))\n     Min.   1st Qu.    Median      Mean   3rd Qu.      Max. \n0.0006386 0.2646350 0.5089532 0.5088928 0.7493618 0.9828082\n</code></pre> <p>Modify the <code>summary()</code> function so that the output also adds a column containing the standard deviation of the data.</p> <p>In a second step, make sure to call the original summary function to create the output, before adding a new column to it.</p>"},{"location":"practicals_2/#exercice-3","title":"Exercice 3","text":""},{"location":"practicals_2/#a","title":"A","text":"<p>During the course, we discussed how to improve the efficiency of the following expression:</p> <pre><code>n &lt;- 100000\nm &lt;- 100\nresults &lt;- NULL\nfor (i in 1:n) { \n result &lt;- mean( runif( m ) )\n results &lt;- c(results, result)\n}\n</code></pre> <p>Do you have any ideas how you could potentially improve it? (if not, ask for advice or look at exercice 5). Try these, and time them in comparison to the two versions described in the course.</p>"},{"location":"practicals_2/#b","title":"B","text":"<p>If we create the vector with the right size before the loop, does it make a difference if we initially fill it with NAs or with zeros ?</p>"},{"location":"practicals_2/#exercise-4","title":"Exercise 4","text":""},{"location":"practicals_2/#a_1","title":"A","text":"<p>Create an expression similar to the one described in exercise 3 but which returns data in a matrix or dataframe (for example, each iteration of the loop returns 2 values, the mean and the standard deviation, meaning that the end result after the loop would be a dataframe with 2 columns).</p> <p>How can you create the resulting matrix/data frame ?</p> <p>Does it make a difference if the matrix is increased by one row at each iteration, compared to when the matrix is created first and then filled in row by row ?</p>"},{"location":"practicals_2/#b_1","title":"B","text":"<p>Let\u2019s suppose that each iteration of the loop adds an unknown number of results (it could be 0, 1 or more than 1, and this number could be different for each iteration), so that it is impossible to create an empty data structure of the right size and fill it row by row in the loop.</p> <p>Compare the following ways of creating the result:</p> <ul> <li>fill separately several vectors (for example, one vector \u201cmeans\u201d     and one vector \u201csds\u201d), and combine them after the loop to obtain a     matrix or data frame</li> <li>\u201cgrow\u201d a data frame or a matrix by the right number of rows at     every step of the loop (how do you create the empty structure     before the loop ?</li> <li>create small dataframes with results at every step, add them to a     list (we will see later in the course an efficient way to     transform this list into a matrix or a data frame)</li> </ul>"},{"location":"practicals_2/#exercise-5","title":"Exercise 5","text":"<p>Go back to the exercice where we calculated many times the mean of several random numbers). Test if you can obtain further improvements in speed by making the following changes:</p> <ul> <li>create a matrix containing all the random numbers, and use the     <code>apply()</code> command instead of a loop.</li> <li>do not use the <code>mean()</code> function, but calculate the mean manually     (using the <code>sum()</code> function for example)</li> </ul>"},{"location":"practicals_2/#exercice-6","title":"Exercice 6","text":"<p>Improve as much as possible the execution time of the following piece of code (seen in the course):</p> <pre><code>pvalues &lt;- NULL\nfor (i in 1:10000) {\n  a &lt;- runif(6)\n  ttest &lt;- t.test(a[1:3], a[4:6])\n  pval &lt;- ttest$p.value\n  pvalues &lt;- c(pvalues, pval)\n}\n</code></pre>"},{"location":"practicals_more/","title":"Exercise 1","text":"<p>How would you efficiently \u201czip\u201d two vectors in R ? In other words: we have two vectors</p> <pre><code>a &lt;- LETTERS[1:10]      # A, B, C, D...\nb &lt;- 1:10\n</code></pre> <p>and we want to obtain a vector with</p> <pre><code>&gt; zip\n[1] \"A\" \"1\" \"B\" \"2\" \"C\" \"3\" ....\n</code></pre>"},{"location":"practicals_more/#exercise-2","title":"Exercise 2","text":"<p>A) Create a long vector in R, for example</p> <pre><code>d &lt;- 1:1000000\nHow would you efficiently calculate the sum of every 5 adjacent values in the vector\n(without overlap: the sum of the first five elements, the sum of the next five, etc) ?\n\nB)\nHow would you calculate the overlapping sum of 5 adjacent values:\nthe sum of the first five, the sum of the 5 elements starting at the 2nd position, etc\n\n# Exercise 3\nThe following dataset describes the content of a 1024x1024 matrix\n\n```r \nn &lt;- 1024 \ny &lt;- rep( 1:n, each=n ) \nx &lt;- rep( 1:n, times=n ) \nvalue &lt;- rnorm( length(x) )\ndata &lt;- data.frame(x, y, value)\n</code></pre> <p>Each row of the data frame describes one element of the matrix: its row number (x), column number (y), and the actual value.</p> <p>How would you transform this data frame into an actual matrix containing the values (value) at the correct position (as given by each x and y) ?</p>"},{"location":"practicals_more/#exercise-4","title":"Exercise 4","text":"<p>The following code creates a dataset:</p> <p><pre><code>set.seed(1) \ndata &lt;- data.frame(y=rnorm(100), x1=rnorm(100), x2=rnorm(100), group=sample(1:10, 100, replace=T) ) \ndata[ data$group==5, \"y\" ] &lt;- data[ data$group==5, \"x2\" ] + rnorm( sum(data$group==5) )/10\n</code></pre> Write an R program that will:</p> <p>fit a linear model of the form y ~ x1 + x2 separately to the data corresponding to each group return a vector (or another appropriate data structure) containing the p-values for significance of the x2 variable in each model single out the group that produced the lowest such p-value If you used a for loop (over all groups) in your program, rewrite it without using the for loop.</p>"},{"location":"practicals_more/#exercise-5","title":"Exercise 5","text":"<p>This is a follow-up to exercise 3; this time, our data frame has gaps (it does not describe all the elements of the matrix). Create a dataframe with the following code:</p> <pre><code>n &lt;- 1024 y &lt;- rep( 1:n, each=n ) x &lt;- rep( 1:n, times=n )\n\nvalue &lt;- rep(0, length(x)) \ndata &lt;- data.frame(x, y, value) \ndata &lt;- within(data, value[ x&gt;n/4 &amp; x&lt;n*3/4 &amp; y&gt;n/4 &amp; y&lt;n*3/4 ] &lt;- 1 ) \ndata &lt;- within(data, value[ x&gt;n*3/8 &amp; x&lt;n*5/8 &amp; y&gt;n*3/8 &amp; y&lt;n*5/8 ] &lt;- 0 ) \ndata &lt;- data[ data$value &gt; 0, ]\n</code></pre> <p>How do you transform this data.frame into a matrix ? When you are done, plot the matrix using the image() function, and check whether your result is correct.</p>"},{"location":"precourse/","title":"Precourse preparations","text":""},{"location":"precourse/#course-location","title":"Course location","text":"<p>University of Lausanne,  Cubotron Building, UNIL-Sorge Room: CUB-233 (Auditoire III) Map</p> <p>Course time: 9:00 to 17:00 each day. Please arrive a few minutes early.</p>"},{"location":"precourse/#software-to-install","title":"Software to install","text":"<p>Before the course starts, please install R (&gt; version 4.4.0) and the latest version of R Studio.</p> <p>https://cran.r-project.org/ https://rstudio.com/products/rstudio/download/#download</p>"},{"location":"precourse/#shared-doc","title":"Shared Doc","text":"<p>We also have a \u200bdocx icon Shared document to simplify the exchanges of information with you during the lectures Advanced programming with R_September 2024</p> <p>Social Gathering: At the end of Day 1, there will be a Social Ap\u00e9ro at 17h15h. Please, let us know if you wish to attend by Thursday here: https://docs.google.com/forms/d/e/1FAIpQLSeUuR6m283aGf9VcVWfwo68ND6mKSy257iFOoeu_nMnPDmDFw/viewform?usp=pp_url</p> <p>Wi-Fi: with Eduroam account (member of a university): please connect to eduroam wifi network by following the guidelines of your home institution. without Eduroam account: please connect to public-unil or freewifi-epfl, a free, instant Internet access for visitors.</p> <p>Code of Conduct:  SIB abides by the ELIXIR Code of Conduct. We want to ensure all those participating in our courses can interact in a respectful and safe environment. If you experience or witness any unacceptable behavior, please let me know.   </p>"},{"location":"slides_1/","title":"Slides (day 1)","text":""},{"location":"slides_1/#material","title":"Material","text":"<p> Intro slides  Data structures  Object-oriented programming</p>"},{"location":"slides_2/","title":"Slides (day 2)","text":""},{"location":"slides_2/#material","title":"Material","text":"<p> Namespaces and profiling</p> <p> R packages</p> <p>An interesting blog about the evolution of R code and its organization, and a package (srcpkgs) that extends devtools (to develop several R packages in parallel) </p>"},{"location":"solutions_1/","title":"Exercise 1","text":"<p>Suppose we have a list of amino acids, their masses and a protein sequence:</p> <pre><code>aminoacids &lt;- c(\"A\", \"R\", \"N\", \"D\", \"C\", \"E\", \"Q\", \"G\", \"H\", \"I\", \"L\", \"K\", \"M\", \"F\", \"P\", \"S\", \"T\", \"W\", \"Y\", \"V\" )\nmasses &lt;- c(71.0788, 156.1875, 114.1038, 115.0886, 103.1388, 129.1155, 128.1307, 57.0519, 137.1411, 113.1594, 113.1594, 128.1741, 131.1926, 147.1766, 97.1167, 87.0782, 101.1051, 186.2132, 163.1760, 99.1326)\nprotein &lt;- \"MEFARILOP\"\n</code></pre> <p>How can we use R to efficiently calculate the mass of the protein ?</p> <p>We first create a named vector for the masses, and split the protein into amino acids:</p> <pre><code>names(masses) &lt;- aminoacids\naa &lt;- strsplit(protein, \"\")[[1]]\n</code></pre> <p>(<code>strsplit()</code> returns a list with a single element, so we need to extract the vector of amino acids using the bracket notation).</p> <p>We can then use the lookup table to calculate the total, making sure to remove the missing values (non-existent amino acids and separately list the ones that were missing:</p> <pre><code>sum(masses[ aa ], na.rm=TRUE)\n</code></pre> <pre><code>## [1] 958.1865\n</code></pre> <pre><code># List of missing amino acids\naa[ is.na( masses[aa] ) ]\n</code></pre> <pre><code>## [1] \"O\"\n</code></pre>"},{"location":"solutions_1/#exercise-2","title":"Exercise 2","text":"<p>Suppose that you are given information about the amount of fertilizer used on several parts of a field, in the form of a factor:</p> <pre><code>fert &lt;- factor( c(10, 20, 50, 30, 10, 20, 10, 45) )\n</code></pre> <p>Starting from the factor, how would you calculate the mean amount of fertilizer used ?</p> <p>We can not convert to numeric values directly, because we would only get the indices (the link to the levels); we can first convert to character and then to numeric:</p> <pre><code>mean(as.numeric(as.character(fert)))\n</code></pre> <pre><code>## [1] 24.375\n</code></pre> <pre><code>mean(as.numeric(as.vector(fert)))     # equivalent\n</code></pre> <pre><code>## [1] 24.375\n</code></pre>"},{"location":"solutions_1/#exercise-3a","title":"Exercise 3A","text":"<p>The table() function allows you to count the number of occurrences of each value in a vector; for example :</p> <pre><code>set.seed(5)\ndata &lt;- sample(1:10, 10, replace=TRUE)\ndata\n</code></pre> <pre><code>##  [1] 2 9 9 9 5 7 7 3 3 6\n</code></pre> <pre><code>table(data)\n</code></pre> <pre><code>## data\n## 2 3 5 6 7 9 \n## 1 2 1 1 2 3\n</code></pre> <p>However, the table has \u2018gaps\u2019 in it. How could we obtain the same result, but including all numbers from 1 to 10, with a count of \u20180\u2019 when the value does not appear in the vector ?</p> <p>We can make the vector into a factor, and explicitely specify the possible levels (1 to 10); table will then do the right thing:</p> <pre><code>data &lt;- factor( data, levels=1:10 )\ntable(data)\n</code></pre> <pre><code>## data\n##  1  2  3  4  5  6  7  8  9 10 \n##  0  1  2  0  1  1  2  0  3  0\n</code></pre> <p>Side question: the tabulate() function solves part of our question here, but it is not entirely satisfactory. Why ?</p> <pre><code>tabulate(data)\n</code></pre> <pre><code>## [1] 0 1 2 0 1 1 2 0 3\n</code></pre> <p>Tabulate will fill in the gaps, but cannot know that there are larger values (10) missing. This can be specified in its options, however.</p>"},{"location":"solutions_1/#exercise-3b","title":"Exercise 3B","text":"<p>When plotting a boxplot, the order of the groups is generally alphabetical; for example, the boxplot created by the following commands has groups A, AB, B, BA, C.</p> <pre><code>a &lt;- runif(100)\ngroups &lt;- sample( c(\"A\", \"AB\", \"ABC\", \"B\", \"BC\", \"C\", \"CA\"), 100, replace=TRUE)\nboxplot(a ~ groups)\n</code></pre> <p></p> <p>How you can easily force a different order  (e.g. A, B, C, AB, BC, CA, ABC) ?</p> <p>We can make the vector into a factor, and specify the levels in the order we want them:</p> <pre><code>groups &lt;- factor(groups, levels=c(\"A\", \"B\", \"C\", \"AB\", \"BC\", \"CA\", \"ABC\"))\nboxplot(a ~ groups)\n</code></pre> <p></p>"},{"location":"solutions_1/#exercice-3c","title":"Exercice 3C","text":"<p>When conducting the linear regression described below, all groups are compared to the \u201cA\u201d group (as the intercept, chosen because it is the first group in alphabetical order). How can we force the lm function to choose group \u201cref\u201d as the reference ?</p> <pre><code>set.seed(1)\ndata &lt;- runif(100)\ngroups &lt;- rep( c(\"ref\", \"a\", \"b\", \"c\"), each=25)\nsummary(lm(data~groups))\n</code></pre> <p><pre><code>## \n## Call:\n## lm(formula = data ~ groups)\n## \n## Residuals:\n##      Min       1Q   Median       3Q      Max \n## -0.52001 -0.17433  0.00602  0.23320  0.46012 \n## \n## Coefficients:\n##              Estimate Std. Error t value Pr(&gt;|t|)    \n## (Intercept)  0.533400   0.053933   9.890 2.56e-16 ***\n## groupsb     -0.071713   0.076273  -0.940    0.349    \n## groupsc      0.011115   0.076273   0.146    0.884    \n## groupsref   -0.001615   0.076273  -0.021    0.983    \n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## Residual standard error: 0.2697 on 96 degrees of freedom\n## Multiple R-squared:  0.01517,    Adjusted R-squared:  -0.01561 \n## F-statistic: 0.4929 on 3 and 96 DF,  p-value: 0.688\n</code></pre> We can transform the vector of groups into a factor, and specify explicitely which one is the reference (the first level), using the relevel() function.  The model linear that is fitted is exactly the same one, but the display of the coefficients change:</p> <pre><code>groups &lt;- factor(groups)\ngroups &lt;- relevel(groups, \"ref\")\ngroups\n</code></pre> <pre><code>##   [1] ref ref ref ref ref ref ref ref ref ref ref ref ref ref ref ref ref ref\n##  [19] ref ref ref ref ref ref ref a   a   a   a   a   a   a   a   a   a   a  \n##  [37] a   a   a   a   a   a   a   a   a   a   a   a   a   a   b   b   b   b  \n##  [55] b   b   b   b   b   b   b   b   b   b   b   b   b   b   b   b   b   b  \n##  [73] b   b   b   c   c   c   c   c   c   c   c   c   c   c   c   c   c   c  \n##  [91] c   c   c   c   c   c   c   c   c   c  \n## Levels: ref a b c\n</code></pre> <pre><code>summary(lm(data~groups))\n</code></pre> <pre><code>## \n## Call:\n## lm(formula = data ~ groups)\n## \n## Residuals:\n##      Min       1Q   Median       3Q      Max \n## -0.52001 -0.17433  0.00602  0.23320  0.46012 \n## \n## Coefficients:\n##              Estimate Std. Error t value Pr(&gt;|t|)    \n## (Intercept)  0.531786   0.053933   9.860 2.97e-16 ***\n## groupsa      0.001615   0.076273   0.021    0.983    \n## groupsb     -0.070098   0.076273  -0.919    0.360    \n## groupsc      0.012730   0.076273   0.167    0.868    \n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## Residual standard error: 0.2697 on 96 degrees of freedom\n## Multiple R-squared:  0.01517,    Adjusted R-squared:  -0.01561 \n## F-statistic: 0.4929 on 3 and 96 DF,  p-value: 0.688\n</code></pre> <pre><code>groups &lt;- factor(groups, levels=c(\"ref\", \"a\", \"b\", \"c\"), ordered=TRUE)\ngroups\n</code></pre> <pre><code>##   [1] ref ref ref ref ref ref ref ref ref ref ref ref ref ref ref ref ref ref\n##  [19] ref ref ref ref ref ref ref a   a   a   a   a   a   a   a   a   a   a  \n##  [37] a   a   a   a   a   a   a   a   a   a   a   a   a   a   b   b   b   b  \n##  [55] b   b   b   b   b   b   b   b   b   b   b   b   b   b   b   b   b   b  \n##  [73] b   b   b   c   c   c   c   c   c   c   c   c   c   c   c   c   c   c  \n##  [91] c   c   c   c   c   c   c   c   c   c  \n## Levels: ref &lt; a &lt; b &lt; c\n</code></pre> <pre><code>summary(lm(data~groups))\n</code></pre> <pre><code>## \n## Call:\n## lm(formula = data ~ groups)\n## \n## Residuals:\n##      Min       1Q   Median       3Q      Max \n## -0.52001 -0.17433  0.00602  0.23320  0.46012 \n## \n## Coefficients:\n##              Estimate Std. Error t value Pr(&gt;|t|)    \n## (Intercept)  0.517847   0.026966  19.203   &lt;2e-16 ***\n## groups.L    -0.007496   0.053933  -0.139    0.890    \n## groups.Q     0.040607   0.053933   0.753    0.453    \n## groups.C     0.050953   0.053933   0.945    0.347    \n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## Residual standard error: 0.2697 on 96 degrees of freedom\n## Multiple R-squared:  0.01517,    Adjusted R-squared:  -0.01561 \n## F-statistic: 0.4929 on 3 and 96 DF,  p-value: 0.688\n</code></pre>"},{"location":"solutions_1/#exercise-4a","title":"Exercise 4A","text":"<p>The following R code generates random data and fits a linear model:</p> <pre><code>set.seed(1)\nx &lt;- runif(10)\ny &lt;- 2*x + rnorm(10)\nmodel &lt;- lm(y~x)\nsummary(model)\n</code></pre> <pre><code>## \n## Call:\n## lm(formula = y ~ x)\n## \n## Residuals:\n##     Min      1Q  Median      3Q     Max \n## -2.3327 -0.6267  0.2447  0.6006  1.2851 \n## \n## Coefficients:\n##             Estimate Std. Error t value Pr(&gt;|t|)  \n## (Intercept)  -0.1361     0.7648  -0.178    0.863  \n## x             2.4039     1.2186   1.973    0.084 .\n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## Residual standard error: 1.154 on 8 degrees of freedom\n## Multiple R-squared:  0.3273, Adjusted R-squared:  0.2432 \n## F-statistic: 3.891 on 1 and 8 DF,  p-value: 0.08399\n</code></pre> <p>How would you copy into a variable \u201cslope\u201d the slope of the regression line (the second regression coefficient) ? And how would you extract in a variable \u201cpvalue\u201d the p-value associated with it ?</p> <p>We can look at the structure of the linear model:</p> <pre><code>names(model)\n</code></pre> <pre><code>##  [1] \"coefficients\"  \"residuals\"     \"effects\"       \"rank\"         \n##  [5] \"fitted.values\" \"assign\"        \"qr\"            \"df.residual\"  \n##  [9] \"xlevels\"       \"call\"          \"terms\"         \"model\"\n</code></pre> <pre><code>str(model)\n</code></pre> <p><pre><code>## List of 12\n##  $ coefficients : Named num [1:2] -0.136 2.404\n##   ..- attr(*, \"names\")= chr [1:2] \"(Intercept)\" \"x\"\n##  $ residuals    : Named num [1:10] -0.792 0.473 0.643 0.345 -0.251 ...\n##   ..- attr(*, \"names\")= chr [1:10] \"1\" \"2\" \"3\" \"4\" ...\n##  $ effects      : Named num [1:10] -3.762 2.276 0.89 0.802 -0.237 ...\n##   ..- attr(*, \"names\")= chr [1:10] \"(Intercept)\" \"x\" \"\" \"\" ...\n##  $ rank         : int 2\n##  $ fitted.values: Named num [1:10] 0.502 0.758 1.241 2.047 0.349 ...\n##   ..- attr(*, \"names\")= chr [1:10] \"1\" \"2\" \"3\" \"4\" ...\n##  $ assign       : int [1:2] 0 1\n##  $ qr           :List of 5\n##   ..$ qr   : num [1:10, 1:2] -3.162 0.316 0.316 0.316 0.316 ...\n##   .. ..- attr(*, \"dimnames\")=List of 2\n##   .. .. ..$ : chr [1:10] \"1\" \"2\" \"3\" \"4\" ...\n##   .. .. ..$ : chr [1:2] \"(Intercept)\" \"x\"\n##   .. ..- attr(*, \"assign\")= int [1:2] 0 1\n##   ..$ qraux: num [1:2] 1.32 1.12\n##   ..$ pivot: int [1:2] 1 2\n##   ..$ tol  : num 1e-07\n##   ..$ rank : int 2\n##   ..- attr(*, \"class\")= chr \"qr\"\n##  $ df.residual  : int 8\n##  $ xlevels      : Named list()\n##  $ call         : language lm(formula = y ~ x)\n##  $ terms        :Classes 'terms', 'formula'  language y ~ x\n##   .. ..- attr(*, \"variables\")= language list(y, x)\n##   .. ..- attr(*, \"factors\")= int [1:2, 1] 0 1\n##   .. .. ..- attr(*, \"dimnames\")=List of 2\n##   .. .. .. ..$ : chr [1:2] \"y\" \"x\"\n##   .. .. .. ..$ : chr \"x\"\n##   .. ..- attr(*, \"term.labels\")= chr \"x\"\n##   .. ..- attr(*, \"order\")= int 1\n##   .. ..- attr(*, \"intercept\")= int 1\n##   .. ..- attr(*, \"response\")= int 1\n##   .. ..- attr(*, \".Environment\")=&lt;environment: R_GlobalEnv&gt; \n##   .. ..- attr(*, \"predvars\")= language list(y, x)\n##   .. ..- attr(*, \"dataClasses\")= Named chr [1:2] \"numeric\" \"numeric\"\n##   .. .. ..- attr(*, \"names\")= chr [1:2] \"y\" \"x\"\n##  $ model        :'data.frame':   10 obs. of  2 variables:\n##   ..$ y: num [1:10] -0.289 1.232 1.884 2.392 0.098 ...\n##   ..$ x: num [1:10] 0.266 0.372 0.573 0.908 0.202 ...\n##   ..- attr(*, \"terms\")=Classes 'terms', 'formula'  language y ~ x\n##   .. .. ..- attr(*, \"variables\")= language list(y, x)\n##   .. .. ..- attr(*, \"factors\")= int [1:2, 1] 0 1\n##   .. .. .. ..- attr(*, \"dimnames\")=List of 2\n##   .. .. .. .. ..$ : chr [1:2] \"y\" \"x\"\n##   .. .. .. .. ..$ : chr \"x\"\n##   .. .. ..- attr(*, \"term.labels\")= chr \"x\"\n##   .. .. ..- attr(*, \"order\")= int 1\n##   .. .. ..- attr(*, \"intercept\")= int 1\n##   .. .. ..- attr(*, \"response\")= int 1\n##   .. .. ..- attr(*, \".Environment\")=&lt;environment: R_GlobalEnv&gt; \n##   .. .. ..- attr(*, \"predvars\")= language list(y, x)\n##   .. .. ..- attr(*, \"dataClasses\")= Named chr [1:2] \"numeric\" \"numeric\"\n##   .. .. .. ..- attr(*, \"names\")= chr [1:2] \"y\" \"x\"\n##  - attr(*, \"class\")= chr \"lm\"\n</code></pre> The \u201ccoefficients\u201d contains the slope:</p> <pre><code>model$coefficients\n</code></pre> <pre><code>## (Intercept)           x \n##  -0.1361272   2.4039002\n</code></pre> <pre><code>model$coefficients[2]\n</code></pre> <p><pre><code>##      x \n## 2.4039\n</code></pre> Note that this requires knowledge about the structure of the variable; it is much better to use an accessor function, such as coef(), and to use the name of the variable we are interested in rather than the position:</p> <pre><code>coef(model)[2]\n</code></pre> <pre><code>##      x \n## 2.4039\n</code></pre> <pre><code>coef(model)[\"x\"]\n</code></pre> <pre><code>##      x \n## 2.4039\n</code></pre> <pre><code>getAnywhere(coef.default)\n</code></pre> <pre><code>## A single object matching 'coef.default' was found\n## It was found in the following places\n##   registered S3 method for coef from namespace stats\n##   namespace:stats\n## with value\n## \n## function (object, complete = TRUE, ...) \n## {\n##     cf &lt;- object$coefficients\n##     if (complete) \n##         cf\n##     else cf[!is.na(cf)]\n## }\n## &lt;bytecode: 0x5628eb6e0068&gt;\n## &lt;environment: namespace:stats&gt;\n</code></pre> <p>Using coef provides the same result as direct access, but will continue to work even if the structure of the object changes.</p> <p>The p-value, however, is not provided in this table. This is because it is actually calculated only when we ask for the summary:</p> <pre><code>modelsummary &lt;- summary(model)\nclass(modelsummary)\n</code></pre> <pre><code>## [1] \"summary.lm\"\n</code></pre> <pre><code>names(modelsummary)\n</code></pre> <pre><code>##  [1] \"call\"          \"terms\"         \"residuals\"     \"coefficients\" \n##  [5] \"aliased\"       \"sigma\"         \"df\"            \"r.squared\"    \n##  [9] \"adj.r.squared\" \"fstatistic\"    \"cov.unscaled\"\n</code></pre> <pre><code>modelsummary$coefficients   # or, equivalently:\n</code></pre> <pre><code>##               Estimate Std. Error    t value   Pr(&gt;|t|)\n## (Intercept) -0.1361272   0.764750 -0.1780023 0.86314593\n## x            2.4039002   1.218592  1.9726860 0.08399393\n</code></pre> <pre><code>coef(modelsummary)\n</code></pre> <pre><code>##               Estimate Std. Error    t value   Pr(&gt;|t|)\n## (Intercept) -0.1361272   0.764750 -0.1780023 0.86314593\n## x            2.4039002   1.218592  1.9726860 0.08399393\n</code></pre> <pre><code>coef(modelsummary)[2,4]\n</code></pre> <pre><code>## [1] 0.08399393\n</code></pre> <pre><code>coef(modelsummary)[\"x\", \"Pr(&gt;|t|)\"]\n</code></pre> <pre><code>## [1] 0.08399393\n</code></pre>"},{"location":"solutions_1/#exercise-4b","title":"Exercise 4B","text":"<p>The following code fits an ANOVA model:</p> <pre><code>set.seed(1)\ngroups &lt;- rep(LETTERS[1:3], each=5 )\ndata &lt;- rnorm( length(groups) )\nmodel_anova &lt;- aov( data ~ groups )\nsummary(model_anova)\n</code></pre> <pre><code>##             Df Sum Sq Mean Sq F value Pr(&gt;F)\n## groups       2   0.03  0.0148   0.012  0.988\n## Residuals   12  14.47  1.2059\n</code></pre> <p>How would you extract the p-value provided by this model into a \u201cpvalue\u201d variable ?</p> <p>As before, we need to look into the object to understand its structure, using str() for example. We find that the object contains a list of length 1, which contains a data.frame with the information we require:</p> <pre><code>mysummary &lt;- summary(model_anova)\nstr(mysummary)\n</code></pre> <pre><code>## List of 1\n##  $ :Classes 'anova' and 'data.frame':    2 obs. of  5 variables:\n##   ..$ Df     : num [1:2] 2 12\n##   ..$ Sum Sq : num [1:2] 0.0296 14.4702\n##   ..$ Mean Sq: num [1:2] 0.0148 1.2059\n##   ..$ F value: num [1:2] 0.0123 NA\n##   ..$ Pr(&gt;F) : num [1:2] 0.988 NA\n##  - attr(*, \"class\")= chr [1:2] \"summary.aov\" \"listof\"\n</code></pre> <pre><code>mysummary[[1]][\"groups\", \"Pr(&gt;F)\"]\n</code></pre> <pre><code>## [1] 0.9878183\n</code></pre>"},{"location":"solutions_1/#exercise-5","title":"Exercise 5","text":"<p>Check how R implements \u201cfactors\u201d in principle. For example, where are the labels and the fact that the factor is ordered stored ? Where is the function that prints a factor, and the function that makes a summary out of the factor ?</p> <p>Looking at the summary or the names of the object does not tell us anything.  We can use the <code>str()</code> command to show us some information about the structure:</p> <pre><code>fert &lt;- factor( c(10, 20, 50, 30, 10, 20, 10, 45) )\nstr(fert)\n</code></pre> <pre><code>##  Factor w/ 5 levels \"10\",\"20\",\"30\",..: 1 2 5 3 1 2 1 4\n</code></pre> <p>It does not tell us much about how the data is stored; one other way is to remove the \u201cfactor\u201d class, and see what default object is printed:</p> <pre><code>class(fert) &lt;- \"\"\nfert\n</code></pre> <pre><code>## [1] 1 2 5 3 1 2 1 4\n## attr(,\"levels\")\n## [1] \"10\" \"20\" \"30\" \"45\" \"50\"\n## attr(,\"class\")\n## [1] \"\"\n</code></pre> <pre><code>typeof(fert)\n</code></pre> <pre><code>## [1] \"integer\"\n</code></pre> <p>We see that the data is stored as a vector of integer, and additional information is stored in the attributes of the object. In details:</p> <pre><code>fert &lt;- factor( c(10, 20, 50, 30, 10, 20, 10, 45) )\nattributes(fert)\n</code></pre> <p><pre><code>## $levels\n## [1] \"10\" \"20\" \"30\" \"45\" \"50\"\n## \n## $class\n## [1] \"factor\"\n</code></pre> We can see that the levels of the factor are saved as an attribute, and the class of the variable is set to \u201cfactor\u201d. </p> <pre><code>methods(class=\"factor\")\n</code></pre> <pre><code>##  [1] [             [[            [[&lt;-          [&lt;-           all.equal    \n##  [6] as.character  as.data.frame as.Date       as.list       as.logical   \n## [11] as.POSIXlt    as.vector     c             coerce        droplevels   \n## [16] format        initialize    is.na&lt;-       length&lt;-      levels&lt;-     \n## [21] Math          Ops           plot          print         relevel      \n## [26] relist        rep           show          slotsFromS3   summary      \n## [31] Summary       xtfrm        \n## see '?methods' for accessing help and source code\n</code></pre> <pre><code># print.factor\n# summary.factor\n</code></pre> <p>We can see in the list the methods print and summary, so that the two functions are print.factor and summary.factor (which you can print and look at if you want)</p> <pre><code>fert &lt;- factor( c(10, 20, 50, 30, 10, 20, 10, 45), ordered=TRUE )\nattributes(fert)\n</code></pre> <pre><code>## $levels\n## [1] \"10\" \"20\" \"30\" \"45\" \"50\"\n## \n## $class\n## [1] \"ordered\" \"factor\"\n</code></pre> <p>In the case of an ordered factor, there is a second class, \u201cordered\u201d; otherwise, the data is stored in the same way.</p>"}]}